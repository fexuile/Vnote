vnote_backup_file_826537664 /home/mleautomaton/VNote/Algorithm/贪心/[NOI2010]航空管制.md
# [NOI2010]航空管制

[Luogu1954]

给你 $n$ 次航班,每一趟航班都有一个最晚起飞时间 $k_i$ .在这些航班中,还有 $m$ 个二元关系 $(a,b)$ 表示 $a$ 要在 $b$ 前面起飞.求一组可行的方案并求出每一趟航班的最早起飞序号.

首先考虑第一问,我们要把 $k_i$ 最大的放到最后面,那么直接建个反图然后拓扑排序即可.

第二问的话考虑忽略当前这趟航班,如果存在一个时间点 $t$ 满足没有飞机可以起飞,那么答案就是 $t$ . 

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define re register
#define ll long long
#define mp make_pair
typedef pair<int,int> pii;
inline int gi()
{
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=2010;
vector<int>G[N];
int n,m,d[N],tot,p[N],b[N],D[N];
priority_queue<pii>q;
int solve(int id)
{
	while(!q.empty())q.pop();
	for(int i=1;i<=n;i++)D[i]=d[i];D[id]=n+1;
	for(int i=1;i<=n;i++)if(!D[i])q.push(mp(b[i],i));
	int tot=n;
	while(!q.empty())
	{
		int u=q.top().second;q.pop();
		if(b[u]<tot)return tot;tot--;
		for(int v:G[u])
			if(!--D[v])q.push(mp(b[v],v));
	}
	return tot;
}
int main()
{
	n=gi();m=gi();
	for(int i=1;i<=n;i++)b[i]=gi();
	while(m--){
		int a=gi(),b=gi();
		G[b].push_back(a);d[a]++;
	}
	for(int i=1;i<=n;i++)D[i]=d[i];
	for(int i=1;i<=n;i++)if(!D[i])q.push(mp(b[i],i));
	tot=n;
	while(!q.empty()){
		int u=q.top().second;q.pop();
		p[tot--]=u;
		for(int v:G[u])
			if(!--D[v])q.push(mp(b[v],v));
	}
	for(int i=1;i<=n;i++)printf("%d%c",p[i],i==n?'\n':' ');
	for(int i=1;i<=n;i++)printf("%d ",solve(i));puts("");
	return 0;
}
```