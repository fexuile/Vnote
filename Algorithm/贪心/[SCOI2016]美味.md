# [SCOI2016]美味

[Luogu3293]

现在给你 n 个数字 $a_i$ ,有 m 次询问,每一次给出 $b,x,l,r$ , 要你求出 $b \oplus (a_i-x)$ 的最大值,其中 $\oplus$ 表示异或.

一般的, $Trie$ 树是做不了这种带偏移位置的异或题目,那么我们可以考虑$Trie$树的本质,即查询是不是存在一个.类似的,我们可以按位贪心,然后求出来每一位是否可以取即可.

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define re register
#define ll long long
inline int gi()
{
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
const int N=200010,Mx=300000;
int n,m,tot,rt[N];
struct node{int ls,rs,s;}t[N*200];
void modify(int &x,int y,int l,int r,int pos)
{
	x=++tot;t[x]=t[y];t[x].s++;if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)modify(t[x].ls,t[y].ls,l,mid,pos);
	else modify(t[x].rs,t[y].rs,mid+1,r,pos);
}
int query(int x,int y,int l,int r,int posl,int posr)
{
	if(l>posr||r<posl||posl>posr)return 0;
	if(posl<=l&&r<=posr)return (t[y].s-t[x].s>0);
	int mid=(l+r)>>1,res=0;
	if(posl<=mid)res|=query(t[x].ls,t[y].ls,l,mid,posl,posr);
	if(mid<posr)res|=query(t[x].rs,t[y].rs,mid+1,r,posl,posr);
	return res;
}
bool exist(int l,int r,int pl,int pr)
{
	pl=max(pl,0);pl=min(pl,Mx);pr=max(pr,0);pr=min(pr,Mx);
	return query(rt[l-1],rt[r],0,Mx,pl,pr);
}
int main()
{
	n=gi();m=gi();
	for(int i=1;i<=n;i++)modify(rt[i],rt[i-1],0,Mx,gi());
	while(m--)
	{
		int b=gi(),x=gi(),l=gi(),r=gi(),ans=0;
		for(int i=17;~i;i--)
		{
			int fl=!(b>>i&1);
			if(fl&&exist(l,r,ans+(1<<i)-x,ans+(1<<i+1)-1-x))ans|=1<<i;
			else if(!fl&&!exist(l,r,ans-x,ans+(1<<i)-1-x))ans|=1<<i;
		}
		printf("%d\n",ans^b);
	}
	return 0;
}
```